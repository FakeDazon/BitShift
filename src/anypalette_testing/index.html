<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>AnyPalette.js Demo</title>
		<style>
			.color {
				display: inline-block;
				width: 20px;
				height: 20px;
			}
		</style>
	</head>
	<body>
		<script src="lib/jquery-3.5.1.js"></script>
		<script src="build/anypalette-0.6.0.js"></script>
		<script>
			function PaletteView(palette_name, url){
				
				var $section = $("<div>");
				//var $header = $("<h2>").appendTo($section);
				var $output = $("<div>").appendTo($section);
				
				//var $toggle_dupes = $("<button>").appendTo($header).hide();
				//var $save = $("<button>").appendTo($header);
				
				/*var $header_inner;
				if(url){
					$header_inner = $("<a>")
						.attr("href", url)
						.appendTo($header);
				}else{
					$header_inner = $("<span>");
				}
				$header_inner
					.prependTo($header)
					.addClass("header-text")
					.text(palette_name.replace(/.*\//, ""));*/
				
				this.appendTo = function(e){
					$section.appendTo(e);
				};
				
				this.update = function(error, palette, formatUsed, matchedFileExtension){
					
					var show_colors = function(palette){
						$output.empty();
						var $row = $("<div class='palette-row'>").appendTo($output);
						var col = 0;
						palette.forEach(function(color, i){
							$("<div class='color'>")
								.appendTo($row)
								.css("background-color", color)
								.attr("title", color.name ? (color.name + "\n" + color) : color)
							
							col += 1;
							if(col >= palette.numberOfColumns){
								col = 0;
								$row = $("<div class='palette-row'>").appendTo($output);
							}
						});
					};
					const update_display = ()=> {
						show_colors(AnyPalette.uniqueColors(palette));
					};
					update_display();
					/*
					$toggle_dupes.on("click", function(e){
						showing_dupes = !showing_dupes;
						update_display();
					});
					$toggle_dupes.on("mousedown", function(e){
						e.preventDefault();
					});
					
					if(n_dupes > 0){
						$toggle_dupes.show();
						if(palette.geometrySpecifiedByFile){
							$toggle_dupes.click();
						}
					}*/

					/*$save.text("Save As...");
					$save.on("click", () => {
						if ($save.parent().find(".fan").length) {
							$save.parent().find(".fan").remove();
							return;
						}
						const formats = Object.values(AnyPalette.formats).filter((format)=> format.write);
						const $fan = $("<div class='fan'>");
						$save.after($fan);
						formats.forEach((format)=> {
							const $option = $("<button class='fan-option'>");
							$option.text(`${format.name} (.${format.fileExtensions[0]})`);
							$option.on("click", () => {
								var file_content = AnyPalette.writePalette(palette, format);
								var file = new File([file_content], `${palette_name.replace(/.*\//, "")}.${format.fileExtensions[0]}`);
								var url = URL.createObjectURL(file);
								var a = document.createElement("a");
								a.href = url;
								a.download = file.name;
								document.body.appendChild(a);
								a.click();
								document.body.removeChild(a);
							});
							$fan.append($option);
						});
					});*/
				};
			}
			

			function addPaletteViewsFromFiles(files){
				files.forEach((file, i)=> {
					var palette_view = new PaletteView("➢ "+file.name);
					palette_view.appendTo("body");
					
					setTimeout(function(){
						AnyPalette.loadPalette(file, function(err, palette, formatUsed, matchedFileExtension){
							palette_view.update(err, palette, formatUsed, matchedFileExtension);
							if (palette) {
								window.console && console.log(`New palette: ${palette.map(()=> `%c█`).join("")}`, ...palette.map((color)=> `color: ${color};`));
								window.console && console.log(palette);
							}
						});
					}, i * 100); //stagger loading
				});
			}
			
			// TODO: drop indicator
			$(window).on("dragover dragenter", function(e){
				e.preventDefault();
				e.stopPropagation();
			}).on("drop", async function(e){
				e.preventDefault();
				e.stopPropagation();
				
				const dt = e.originalEvent.dataTransfer;
				if (!dt) return;
				if (dt.items) {
					console.log(dt.items)
					const items = await getAllFileEntries(dt.items);
					if(!items) return
					const files = await Promise.all(items.map((item)=> new Promise((resolve, reject)=> {
						item.file(resolve, reject);
					})));
					addPaletteViewsFromFiles(files.length ? files : [...dt.files]);
				} else if(dt.files){
					addPaletteViewsFromFiles([...dt.files]);
				}
			});
			
			// Drop handler function to get all files
			async function getAllFileEntries(dataTransferItemList) {
				let fileEntries = [];
				// Use BFS to traverse entire directory/file structure
				let queue = [];
				// Unfortunately dataTransferItemList is not iterable i.e. no forEach
				for (let i = 0; i < dataTransferItemList.length; i++) {
					const entry = dataTransferItemList[i].webkitGetAsEntry();
					if (entry) {
						queue.push(entry);
					}
				}
				while (queue.length > 0) {
					let entry = queue.shift();
					if (entry.isFile) {
						fileEntries.push(entry);
					} else if (entry.isDirectory) {
						return false
					}
				}
				return fileEntries;
			}


		</script>
	</body>
</html>